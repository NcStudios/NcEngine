#pragma once

#include "ManifoldCache.h"
#include "TriggerCache.h"
#include "ecs/Registry.h"
#include "physics/PhysicsPipelineTypes.h"
#include "physics/collision/IntersectionQueries.h"
#include "physics/dynamics/Constraint.h"

#include <span>

namespace nc
{
class CollisionLogic;

namespace physics
{
class NarrowPhase
{
    public:
        NarrowPhase(Registry* registry);

        /** Transform contact points to updated worldspace positions and remove stale points from manifolds.
        *   Remove any manifolds with no remaining contact points. */
        void UpdateManifolds();

        /** Detect physics-based collisions and add generate contact points. */
        template<Proxy ProxyType>
        void FindPhysicsPairs(std::span<const BroadPair<ProxyType>> pairs);

        /** Detect trigger-based collisions. This can run parallel to the physics
         *  function. It must finish before calling NotifyEvents(). */
        template<Proxy ProxyType>
        void FindTriggerPairs(std::span<const BroadPair<ProxyType>> pairs);

        /** Add externally generated contact points and remove any stale manifolds. */
        void MergeContacts(const NarrowPhysicsResult& externalResults);

        /** Store contact impulses generated by the solver. */
        void CacheImpulses(std::span<const ContactConstraint> constraints);

        /** Send collision and trigger events to components. */
        void NotifyEvents();

        auto Manifolds() const -> std::span<const Manifold> { return m_manifoldCache.Data(); }

        /** Clear the manifold and trigger caches. */
        void Clear();

    private:
        Registry* m_registry;
        ManifoldCache m_manifoldCache;
        TriggerCache m_triggerCache;

        auto TryGetCollisionLogic(Entity) -> CollisionLogic*;
};

template<Proxy ProxyType>
void NarrowPhase::FindPhysicsPairs(std::span<const BroadPair<ProxyType>> physicsPairs)
{
    const auto broadEventCount = physicsPairs.size();
    NarrowPhysicsResult results;
    results.contacts.reserve(broadEventCount);
    results.events.reserve(broadEventCount);
    CollisionState state;

    for(auto& [i, j, eventType] : physicsPairs)
    {
        const auto& bva = i->Volume();
        const auto& bvb = j->Volume();
        if(Collide(bva, bvb, i->Matrix(), j->Matrix(), &state))
        {
            const auto e1 = i->entity;
            const auto e2 = j->entity;
            const auto useStickyContacts = UseStickyContacts(e1, e2, bva, bvb);
            results.events.emplace_back(e1, e2, eventType, useStickyContacts, NarrowEvent::State::New);
            results.contacts.push_back(state.contact);
        }
    }

    const auto dynamicEventCount = results.contacts.size();
    for(size_t i = 0u; i < dynamicEventCount; ++i)
    {
        const auto& [a, b, type, sticky, unused] = results.events[i];
        m_manifoldCache.Add(a, b, type, sticky, results.contacts[i]);
    }
}

template<Proxy ProxyType>
void NarrowPhase::FindTriggerPairs(std::span<const BroadPair<ProxyType>> triggerPairs)
{
    for(const auto& [i, j, type] : triggerPairs)
    {
        if(Intersect(i->Volume(), j->Volume(), i->Matrix(), j->Matrix()))
        {
            m_triggerCache.Add(i->entity, j->entity, type);
        }
    }
}
} // namespace physics
} // namespace nc
